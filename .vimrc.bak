set encoding=utf-8

scriptencoding utf-8

augroup myVimrc
    autocmd!
augroup END

filetype off
filetype plugin indent off


if has('vim_starting')
    set runtimepath+=~/.vim/bundle/neobundle.vim
endif


" å„ç¨®è¨­å®š
" {{{

" è¡¨ç¤ºç³»ï¼ˆã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ©ã‚¤ãƒ³ã®è¡¨ç¤ºã¯lightlineãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãŒå„ªå…ˆã•ã‚Œã‚‹ï¼‰
set number       "è¡Œç•ªå·è¡¨ç¤º
set laststatus=2 "ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ©ã‚¤ãƒ³ã‚’å¸¸ã«è¡¨ç¤º

"ã‚«ãƒ©ãƒ¼è¡¨ç¤º
syntax enable
"ã‚ªãƒ¼ãƒˆã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆ
set smartindent
" <BS>ã§ä½•ã§ã‚‚æ¶ˆã›ã‚‹
set backspace=start,eol,indent

" ã‚¿ãƒ–ã‚¹ãƒšãƒ¼ã‚¹ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯åŠè§’ã‚¹ãƒšãƒ¼ã‚¹2æ–‡å­—
set tabstop=2 shiftwidth=2 softtabstop=2
set expandtab

" æ¤œç´¢ç³»
set ignorecase  "æ¤œç´¢æ–‡å­—åˆ—ãŒå°æ–‡å­—ã®å ´åˆã¯å¤§æ–‡å­—å°æ–‡å­—ã‚’åŒºåˆ¥ãªãæ¤œç´¢ã™ã‚‹
set smartcase   "æ¤œç´¢æ–‡å­—åˆ—ã«å¤§æ–‡å­—ãŒå«ã¾ã‚Œã¦ã„ã‚‹å ´åˆã¯åŒºåˆ¥ã—ã¦æ¤œç´¢ã™ã‚‹
set wrapscan    "æ¤œç´¢æ™‚ã«æœ€å¾Œã¾ã§è¡Œã£ãŸã‚‰æœ€åˆã«æˆ»ã‚‹
set noincsearch "æ¤œç´¢æ–‡å­—åˆ—å…¥åŠ›æ™‚ã«é †æ¬¡å¯¾è±¡æ–‡å­—åˆ—ã«ãƒ’ãƒƒãƒˆã•ã›ãªã„
set nohlsearch  "æ¤œç´¢çµæœæ–‡å­—åˆ—ã®éãƒã‚¤ãƒ©ã‚¤ãƒˆè¡¨ç¤º

" ã‚«ãƒ¬ãƒ³ãƒˆè¡Œã«ä¸‹ç·šã‚’è¡¨ç¤ºã™ã‚‹
set cursorline

" ã‚³ãƒãƒ³ãƒ‰å±¥æ­´
set history=100

" è£œå®Œæ™‚ã«ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚¦ã‚¤ãƒ³ãƒ‰ã‚¦ã‚’è¡¨ç¤ºã•ã›ãªã„
set completeopt=menuone,menu

" "ã‚¿ãƒ–ã€ç©ºç™½ã€æ”¹è¡Œã®å¯è¦–åŒ–
" set list
" set listchars=eol:Â¶

" æŠ˜ã‚ŠãŸãŸã¿æ©Ÿèƒ½ã®æœ‰åŠ¹åŒ–
set foldmethod=marker

" éš ã‚Œãƒãƒƒãƒ•ã‚¡ã®æœ‰åŠ¹åŒ–
set hidden

" Go
autocmd myVimrc BufRead,BufNew,BufNewFile *.go setlocal filetype=go

" }}}


" NeoBudleé–¢ä¿‚
" {{{
" NeoBundleãŒãªã„å ´åˆã€ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã™ã‚‹
if !isdirectory(expand('~/.vim/bundle'))
    silent call mkdir(expand('~/.vim/bundle'), 'p')
    silent !git clone https://github.com/Shougo/neobundle.vim $HOME/.vim/bundle/neobundle.vim
    echo "Installed neobundle.vim"
    if v:shell_error
        echorerr "neobundle.vim intallation has failed!"
    endif
endif

call neobundle#begin(expand('~/.vim/bundle'))

" ã“ã“ã«ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ãŸã„ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®ãƒªã‚¹ãƒˆã‚’æ›¸ã
" Unite
NeoBundle 'Shougo/unite.vim'
NeoBundle 'Shougo/neomru.vim'
NeoBundle 'h1mesuke/unite-outline'

" Vimã§éåŒæœŸå‡¦ç†ã‚’å®Ÿç¾ã™ã‚‹
NeoBundle 'Shougo/vimproc.vim', {
            \ 'build' : {
            \   'cygwin' : 'make -f make_cygwin.mak',
            \   'mac'    : 'make -f make_mac.mak',
            \   'unix'   : 'make -f make_unix.mak',
            \   }
            \ }

" vimshell
NeoBundle 'Shougo/vimshell.vim', {
            \ 'depends' :
            \     ['Shougo/vimproc.vim']
            \ }

" Vimã§web-apiã‚’ä½¿ç”¨ã™ã‚‹
NeoBundle 'mattn/webapi-vim'

" Vimã‹ã‚‰ãƒ–ãƒ©ã‚¦ã‚¶ã‚’é–‹ã
NeoBundle 'tyru/open-browser.vim'

" åˆ—æ•´å½¢
NeoBundle 'junegunn/vim-easy-align'

" lightline.vimï¼ˆã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ©ã‚¤ãƒ³è¡¨ç¤ºãƒ—ãƒ©ã‚°ã‚¤ãƒ³ï¼‰
NeoBundle 'itchyny/lightline.vim'

" fugitive.vimï¼ˆGité–¢é€£ã€‚ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒ©ã‚¤ãƒ³ã«ãƒ–ãƒ©ãƒ³ãƒè¡¨ç¤ºã•ã›ã¦ã„ã‚‹ã®ã‚‚ã“ã‚Œï¼‰
NeoBundle 'tpope/vim-fugitive'
NeoBundle 'airblade/vim-gitgutter'

" ã‚³ãƒ¡ãƒ³ãƒˆON/OFFã‚’æ‰‹è»½ã«å®Ÿè¡Œ
NeoBundle 'tomtom/tcomment_vim'

" railsä¾¿åˆ©ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ï¼ˆmodelã¨ã‹viewã¨ã‹ã«ã™ãç§»å‹•ã§ããŸã‚Šã™ã‚‹ï¼‰
NeoBundle 'tpope/vim-rails'

" ãƒ„ãƒªãƒ¼è¡¨ç¤º
NeoBundle 'scrooloose/nerdtree'

" Rubyã‚„Vim Scriptã§end(endif)ç­‰ã‚’è‡ªå‹•çš„ã«ã¤ã‘ã¦ãã‚Œã‚‹
NeoBundle 'tpope/vim-endwise'

" fã®å€™è£œã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
NeoBundle 'deris/vim-shot-f'

" ã‚«ãƒ©ãƒ¼ã‚¹ã‚­ãƒ¼ãƒ 
NeoBundle 'sjl/badwolf'
NeoBundle 'altercation/vim-colors-solarized'
NeoBundle 'w0ng/vim-hybrid'
NeoBundle 'tomasr/molokai'
NeoBundle 'jpo/vim-railscasts-theme'

" æ‹¬å¼§è£œå®Œ
NeoBundle 'jiangmiao/auto-pairs'

" å¤©æ°—äºˆå ±
NeoBundle 'mizukmb/otenki.vim', {
            \ 'depends' : [
            \   'mattn/webapi-vim',
            \   ]
            \ }

" mocho.vimï¼ˆã‚ã£ã¡ã‚ƒã™ã”ã„ï¼ï¼ï¼ï¼ï¼‰
NeoBundle 'mizukmb/mocho'

" syntacs check
NeoBundle 'scrooloose/syntastic'

" è£œå®Œæ©Ÿèƒ½
NeoBundle 'Shougo/neocomplete.vim'

" ãƒ†ã‚­ã‚¹ãƒˆã‚’å›²ã†ã‚‚ã®("",'',{}ãªã©)ã®ç·¨é›†ã‚’è£œåŠ©ã™ã‚‹
NeoBundle 'tpope/vim-surround'

" rustå…¬å¼ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ï¼ˆã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆã€ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ãƒã‚¤ãƒ©ã‚¤ãƒˆï¼‰
NeoBundle 'rust-lang/rust.vim'

" rustdoc
NeoBundle 'rhysd/rust-doc.vim'

" vim-quickrun
NeoBundle 'thinca/vim-quickrun'

" Golangã®è¨­å®šï¼ˆFmt, Inport, Godocã‚³ãƒãƒ³ãƒ‰ã®æä¾›ï¼‰
NeoBundleLazy 'fatih/vim-go', {
      \ 'autoload' : { 'filetypes' : 'go' },
      \ }
" NeoBundleLazy 'vim-jp/vim-go-extra', {
"             \ 'autoload' : { 'filetypes' : 'go' }
"             \ }
" NeoBundleLazy 'Blackrush/vim-gocode', {"autoload": {"filetypes": ['go']}}

" Rustã®è£œå®Œ
NeoBundleLazy 'phildawes/racer', {
            \ 'build' : {
            \   'mac'  : 'cargo build --release',
            \   'unix' : 'cargo build --release',
            \   },
            \ 'autoload' : {
            \   'filetypes' : 'rust',
            \   },
            \ }

" Elixir ã®ã‚·ãƒ³ã‚¿ãƒƒã‚¯ã‚¹ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚„FileTypeã®è¨­å®šç­‰
NeoBundle "elixir-lang/vim-elixir"

" Gist
NeoBundle "mattn/gist-vim"

" Unite ghq
NeoBundle "sorah/unite-ghq"

call neobundle#end()


" required
filetype plugin indent on
" }}}


" ã‚­ãƒ¼ãƒãƒƒãƒ”ãƒ³ã‚°
" {{{

" <leader>ã«è¨­å®šã™ã‚‹ã‚­ãƒ¼
let mapleader = " "


noremap j gj
noremap k gk
noremap gj j
noremap gk k
noremap <S-h> g^
noremap <S-j> }
noremap <S-k> {
noremap <S-l> g$
noremap :  ;
noremap ;  :
noremap / /\v

nnoremap <CR> A<CR><ESC>
nnoremap == gg=G''
nnoremap s <Nop>
nnoremap <silent> ss :split<CR>
nnoremap <silent> sv :vsplit<CR>
nnoremap <silent> sh <C-w>h
nnoremap <silent> sj <C-w>j
nnoremap <silent> sk <C-w>k
nnoremap <silent> sl <C-w>l
nnoremap <Leader>n  :NERDTree<CR>
nnoremap <Leader>v  :vs<CR>:<C-u>VimShell<CR>
nnoremap <Leader>o  :OtenkiTomorrow<CR>
nnoremap <Leader>oh :Otenki hachinohe<CR>
nnoremap <Leader>q  :QuickRun<CR>
nnoremap <Leader>ub :Unite<Space>buffer<CR>
nnoremap <Leader>uf :Unite<Space>file<CR>
nnoremap <Leader>ug :Unite<Space>ghq<CR>
nnoremap <Leader>um :Unite<Space>file_mru<CR>
nnoremap <Leader>uy :Unite<Space>yank<CR>

inoremap <C-f> <C-x><C-o>
inoremap <silent> <C-u> <Esc>u<Insert>
inoremap <silent> <C-r> <Esc><C-r><Insert>
inoremap <silent> <C-p> <Esc>p<Insert>

vmap <Enter> <Plug>(EasyAlign)

imap <F2> <nop>
set pastetoggle=<F2>
" }}}


" ãƒ—ãƒ©ã‚°ã‚¤ãƒ³è¨­å®š
" {{{

" Uniteã®è¨­å®š
let g:unite_enable_start_insert=1
let g:unite_source_history_yank_enable =1
let g:unite_source_file_mru_limit = 200

" TweetVimé–¢ä¿‚
" 1ãƒšãƒ¼ã‚¸ã«è¡¨ç¤ºã™ã‚‹æœ€å¤§æ•°
let g:tweetvim_tweet_per_page = 50

" emmitã®è¨­å®š
" HTML/CSSãƒ•ã‚¡ã‚¤ãƒ«ã®ã¿æœ‰åŠ¹
" let g:user_emmet_install_global = 0
" autocmd FileType html,css EmmetInstall

" ã‚«ãƒ©ãƒ¼ã‚¹ã‚­ãƒ¼ãƒ 
colorscheme railscasts
highlight Normal ctermbg=none

" otenki.vimã®è¨­å®š
let g:otenki_cityname_data = 'hakodate'

" neocompleteã®è¨­å®š
let g:neocomplete#enable_at_startup = 1
let g:neocomplete#enable_smart_case = 1
let g:neocomplete#enable_underbar_comletion = 1
let g:neocomplete#enable_camel_case_comletion = 1
let g:neocomplete#max_list = 10
let g:neocomplete#sources#syntax#min_keyword_length = 3
if !exists('g:neocomplete#delimiter_patterns')
  let g:neocomplete#delimiter_patterns= {}
endif
let g:neocomplete#delimiter_patterns.ruby = ['::']
" if !exists('g:neocomplete#force_omni_input_patterns')
"   let g:neocomplete#force_omni_input_patterns = {}
" endif
" let g:neocomplete#force_omni_input_patterns.ruby =
"       \ '[^. *\t]\.\w*\|\h\w*::'

" racerã®è¨­å®š
let $RUST_SRC_PATH = expand('/usr/local/Cellar/rust/1.0.0-alpha.2')

"vim-goã®è¨­å®š
let g:go_fmt_autosave = 1
let g:go_fmt_fail_silently = 1
let g:go_highlight_functions = 1
let g:go_highlight_methods = 1
let g:go_highlight_structs = 1
let g:go_highlight_operators = 1
let g:go_highlight_build_constraints = 1

" vim-quickrunã®è¨­å®š
let g:quickrun_config = {
            \ "_" : {
            \   "runner"                    : "vimproc",
            \   "runner/vimproc/updatetime" : 60,
            \   "outputter/buffer/running_mark" : mocho#echo()
            \ },
            \ }

" gist-vimã®è¨­å®š
let g:github_user = 'mizukmb'
let g:gist_curl_options = "-k"
let g:gist_detect_filetype = 1

" gitgutterã®è¨­å®š
let g:gitgutter_max_signs = 100000

" lightlineã®è¨­å®š
let g:lightline = {
            \ 'colorscheme': 'wombat',
            \ 'mode_map':    {'c': 'NORMAL'},
            \ 'active':      {
            \   'left': [ [ 'mode', 'paste' ], [ 'fugitive', 'filename' ], ['mocho'] ]
            \ },
            \ 'component_function': {
            \   'modified':         'MyModified',
            \   'readonly':         'MyReadonly',
            \   'fugitive':         'MyFugitive',
            \   'filename':         'MyFilename',
            \   'mocho':            'MyMocho',
            \   'filetype':         'MyFiletype',
            \   'fileformat':       'MyFileformat',
            \   'fileencoding':     'MyFileencoding',
            \   'mode':             'MyMode'
            \ }
            \ }


function! MyModified()
    return &ft =~ 'help\|vimfiler\|gundo' ? '' : &modified ? '+' : &modifiable ? '' : '-'
endfunction

function! MyReadonly()
    return &ft !~? 'help\|vimfiler\|gundo' && &readonly ? 'x' : ''
endfunction

function! MyFilename()
    return ('' != MyReadonly() ? MyReadonly() . ' ' : '') .
                \ (&ft == 'vimfiler' ? vimfiler#get_status_string() :
                \  &ft == 'unite' ? unite#get_status_string() :
                \  &ft == 'vimshell' ? vimshell#get_status_string() :
                \ '' != expand('%:t') ? expand('%:t') : '[No Name]') .
                \ ('' != MyModified() ? ' ' . MyModified() : '')
endfunction

function! MyFugitive()
    try
        if &ft !~? 'vimfiler\|gundo' && exists('*fugitive#head')
            let _ = fugitive#head()
            return strlen(_) ? 'ğŸ£ '._ : ''
        endif
    catch
    endtry
    return ''
endfunction

function! MyFileformat()
    return winwidth(0) > 70 ? &fileformat : ''
endfunction

function! MyFiletype()
    return winwidth(0) > 70 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
endfunction

function! MyFileencoding()
    return winwidth(0) > 70 ? (strlen(&fenc) ? &fenc : &enc) : ''
endfunction

function! MyMode()
    return winwidth(0) > 60 ? lightline#mode() : ''
endfunction

function! MyMocho()
    return winwidth(0) > 70 ? StatusMocho() : ''
endfunction



" function! MyOtenki()
"     return winwidth(0) > 70 ? MyStatusOtenki() : ''
" endfunction
" }}}


" ãã®ä»–è¨­å®š
" {{{

" ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã„ãŸéš›ã«ã€å‰å›çµ‚äº†æ™‚ã®è¡Œã§èµ·å‹•
autocmd myVimrc BufReadPost * if line("'\"") > 0 && line("'\"") <= line("$") |
            \ exe "normal g`\"" |
            \ endif

" Go setting
function! s:golang_settings()
    " Goè¨€èªã¯ãƒãƒ¼ãƒ‰ã‚¿ãƒ–æ¨å¥¨
    setlocal noexpandtab
    let g:syntatic_mode_map = {
                \ 'active_filetypes' : [ 'go' ] 
                \ }
    let g:syntatic_go_checkers = ['go', 'golint']
endfunction
autocmd myVimrc FileType go call <SID>golang_settings()

" Ruby settig
function! s:ruby_settings()
    setlocal tabstop=2 shiftwidth=2 softtabstop=2 
endfunction
autocmd myVimrc FileType ruby call <SID>ruby_settings()

" HTML setting
function! s:html_settings()
    setlocal tabstop=2 shiftwidth=2 softtabstop=2
    " let g:quickrun_config['html'] = {
    "       \ 'outputter' : 'browser',
    "       \ }
endfunction
autocmd myVimrc FileType html call <SID>html_settings()
" }}}

